[inputs.http.pumba]
    
    # the URL of the local or remote HTTP server
    # Lamina will try to raise an error if invalid URL is specified
    host.url = "https://httpbin.org/uuid"

    # [OPTIONAL] request parameters where you can customize your HTTP requests
    # If this block is empty, a basic GET request with empty payload is made
    
    # Specify the method of HTTP request, valid methods are
    # GET, PATCH, POST and PUT
    req.method = "GET"

    # Request headers
    # This is specified as a TOML key-map so make sure to write all your key-map
    # pairs in a single line, within curly braces, separated by comma and grouped
    # by '=' sign. For example,
    # req.headers = { "key" = "value", "key" = "value", ...}
    req.headers = { "accept" = "application/json"}

    # TODO : check the opened tab in mozilla
    req.params = {}

    # Mention the request data that you may want to submit to the server. For
    # e.g., HTML FORM data. The data mentioned here should be a serialized string
    # and appropriate header for that must be provided in req.headers (if required
    # by the server)
    req.data = ""

    # If you wish this HTTP client to send a data file instead, the specify a
    # valid path of the file in the system. During initial configuration the
    # client will read the file in binary and keep it in memory. The read data
    # will be then used for every poll made by this client.
    req.file = ".vscode/launch.json"

    # Timeout for server response before the client raises warning
    req.timeout_s = 4

    # An array of acceptable HTML status codes, must have atleast one.
    res.success = [200]

    # If the server keeps responding with same content, do you want to ignore it
    # or keep it?
    res.content.allow_duplicates = false

    # Decoding of HTML response content
    # 1. 'auto' - the client will try to automatically decode the content using the response headers
    # 2. 'raw'  - the client will not touch the response content and just relay it in raw binary format
    # 3. <custom> - specify a custom decoder to decode the HTML response content from
    # one of the many available python3.11 decoders. An exhaustive list is 
    # mentioned here
    # https://docs.python.org/3.11/library/codecs.html#standard-encodings
    res.content.decoding = "utf-8"
    
    # specify the string tag you want to assign to the response received from the
    # server by this client. This tag will be used for identifying this payload
    # across the data collection pipeline further (if necessary)
    res.content.tag = "rha"
    
    # Specify the maximum allowed length of response. Set to 0 for no restriction.
    res.content.max_length = 10000

    # Specify the polling frequency in seconds
    poll.rate_s = 5

    # Specify the variance in your polling frequency. If not 0, the client will
    # then poll with frequency_s = base_rate_s Â± variance_s
    # Make sure variance_s > rate_s
    poll.variance_s = 2

    # Specify the number of request attempts the client will make to the server
    # after first error before terminating. These attempts are NOT exponentially
    # backed-off. The fail counter will reset to 0 if client successfully handles
    # the content from server before the fail counter exceeds the max attempts
    poll.max_attempt = 10

    # Specify the logging verbosity for this client, the logs will be prefixed
    # with string OUTPUT - [http.<name>]
    # This logger will be using the Lamina's root logger and will dump its output
    # to same Stream / File as mentioned in the root logger. The level mentioned
    # here will be used for both File and Stream logging of data.
    # The logging levels are same as the root logger's
    # 0 - TRACE     [MOST DETAILED]
    # 1 - DEBUG
    # 2 - INFO
    # 3 - WARN
    # 4 - ERROR
    # 5 - CRITICAL  [MOST CONCISE]
    log.level = 0
